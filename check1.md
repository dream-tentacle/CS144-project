## Program Structure and Design
##### 前言
这个实验本质上需要实现一个可以记录多个区间的数据结构，每当有新的数据读取时，要根据已有的区间和存储信息进行判断，并将重叠的部分去除。

区间是有位置关系的，因此每次新读取数据时，需要获取已经存储的相近的区间。这就要求我们能快速获取中间的区间。如果是以链表或数组来记录，则需要花费线性时间才能找到特定区间，这样效率较低。

因此，我们提出使用map来作为存储区间信息的数据结构。
##### 实现
map是使用红黑树实现的，单点读取、删除、插入都是$\log n$级别的，优于常见数据结构。要利用map，就需要定义一个结构体作为键，存储区间的两个端点，并定义其大小比较关系。本代码中使用信息的开头下标作为比较的基准，从而方便快速push到writer中。

当插入时，对插入区间进行了一系列判定和剪切，详见代码。

我们对实现的数据结构作出如下规定：任何存储的区间都不能互相重叠。这既是实现空间节省的*必需要求*，又是方便操作的*良好性质*。

当要插入区间时，首先将被它完全覆盖的已存储区间删除，这样后续就只用考虑两侧的重叠情况了。考虑两侧时，使用`lower_bound()`来获取两侧的区间。由于已经删除了中间的若干被覆盖区间，而且根据规定，一开始就没有重叠的区间，所以获取`lower_bound()`的前一个迭代器必然是在插入区间左侧的。如果左右两侧有重叠，还需要考虑插入的区间是否被某个区间完全覆盖，如果如此，则可以直接返回。<br>
可以直接返回并不会影响任何存储内容，因为原本就没有互相重叠，如果插入区间被别人覆盖，那一定不会覆盖其他更小的区间，所以在最开始进行“将被它完全覆盖的已存储区间删除”这一步骤时，实际没有进行任何操作。

进行push时，直接push，然后将对应的区间删除即可。由于维护区间时考虑到了插入的区间必然在writer的capacity之内，因此不需要担心push时容量不够的问题。由于我们在writer中记录了`bytes_pushed_`变量，因此可以直接获取下一次等待的区间开头。

当需要获取`bytes_pending()`时，可以直接将存储的区间全部加起来。

实现细节详见代码注释。

## Implementation Challenges
一些边缘情况在最开始没有考虑到。例如只输入一个""的情况，此时代码中记录的`ending_index`会由于算式`ending_index = first_index + data.length() - 1`而变成-1，我一开始设置的初始值就是-1,而且还认为它等于-1时还没有结束，导致出现错误。

## Experimental results and performance
在我写这篇报告时，我想写“应当尽量合并相邻区间”。但是，如果新插入的区间确实和旁边的区间重叠了（但不是覆盖），是否真的应当合并呢？我进行了如下的尝试（在代码中体现为TYPE1是否define）：

TYPE1：如果发生上述情况，则将新插入区间的已存储部分截断去除<br>
TYPE2：如果发生上述情况，则将已存储部分删除，并将二者合并为一个区间

对两种情况分别运行代码（均取至少第二次运行为准，因为首次运行需要编译），结果如下：

TYPE1：
![](../check1-1.png)
TYPE2：
![](../check1-2.png)

可以看到，这二者几乎很接近，但是TYPE2还是稍微慢了一点。我认为这主要是因为TYPE2需要多查找一次区间，比起让树稍微大一点并没有太多优势。我猜测，当下一次还有邻近区间时，可能会将上一次相邻的两个区间中的某一个给完全覆盖，因此树的节点数量还是差不多的。
