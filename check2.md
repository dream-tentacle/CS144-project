### 前言
这个实验并不难，没有特殊的算法或结构，只需要正确转化几个数字，处理好他们的关系，并判断一些特殊情况就可以了。因此，我将实现方法与挑战写在一起，描述了我整个实验的基本过程。
### 实现的方法和遇到的问题
对于Wrap的`warp()`函数，只需要将`n`转化为32位并加上`zero_point`的值就可以了

对于`unwrap()`函数，我的实现可能不是语句最少的，但是写起来逻辑清晰，不需要复杂的思考。首先通过位运算获取高位和低位，将二者拼接得到`re`。这里没有去管低位应该是正数还是负数，反正在下一步会去处理。<br>
如果`re`比`checkpoint`小，则有可能要返回re，也可能返回re+2^32；如果`re`比`checkpoint`大，则有可能要返回`re`，也可能返回`re-2^32`。<br>
在判断时，不仅需要比较re跟checkpoint的关系，还要考虑一些特殊边界，看会不会小于0或者大于2^64。

TCP Receiver的代码会稍微复杂一些。一开始，我没有注意到接收`SYN`时的情况。此时，由于信息的`seqno`指向的是`SYN`，需要将插入的位置偏移一位才行。（不过由于absolute seqno和index相差一位，在代码中是当本次信息没有`SYN`时减去1）

后来，我遇到了结束位置的acknowledge number的问题。如果当前信息在最后，那么实际上多接收了1位FIN，因此要根据`writer()`是否已经close了来判断是否将`ack_no`+1.

接受、发送都没有问题后，就是进行special测试了。由于讲义中没有描述遇到error的处理需求，在`“Stream error -> RST flag”`任务上我失败了。我查看了用于测试的代码，发现它将`reassembler`的状态设为了error，因此我在代码中加上了对应的`set_error()`并返回的处理。写这段文字时，我发现应当在`receive()`中再加一个判断当前状态是否为error的代码，虽然测试代码中没有测试这种情况，但实际是有可能发生的，即已经发生了错误，但是又接收到了新的消息，这时不必再处理后面的许多代码了，可以直接return（主要是insert()耗时多）。<br>
此外，返回时，如果有了错误，也应当将RST设为True并直接返回一个message。

### 运行结果
由于已经通过了所有测试，这里直接列出运行结果：
![](../check2-2.png)
![](../check2-1.png)